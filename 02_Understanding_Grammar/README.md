# Verilog 문법 기초 요약

Verilog는 하드웨어 회로를 프로그래밍 언어처럼 기술하기 위한 **하드웨어 기술 언어(HDL)**이다.  
C언어나 Python과 달리, “순서대로 실행되는 코드”가 아니라 **동시에 동작하는 회로를 묘사**한다.

---

## 1. 모듈 구조

모든 Verilog 코드는 `module`로 시작하고 `endmodule`로 끝난다.

예시 (인라인 표현):  
`module 모듈이름(입력과 출력 선언); 내부 코드; endmodule`

모듈은 함수나 클래스가 아니라, **하드웨어 블록(회로 단위)** 이다.

---

## 2. 신호 선언

Verilog에서 데이터는 ‘wire’와 ‘reg’ 두 가지 주요 타입으로 표현된다.

- `wire` : 회로 연결선, 즉 **연결용 신호선**  
- `reg` : 저장 가능한 값(플립플롭이나 래치 등)

예시:  
`wire a, b; reg c;`

비트 폭 지정:  
`reg [3:0] count;` → 4비트 레지스터

---

## 3. 리터럴 표기법

Verilog에서는 숫자를 단순히 쓰지 않고, 비트 폭과 진법을 명시한다.

형식: `[비트수]'[기수][값]`

예시:  
- `4'b1010` → 4비트 2진수 1010  
- `8'hFF` → 8비트 16진수 FF  
- `12'd255` → 12비트 10진수 255  

특수한 비트 값도 가능하다.  
`x` (unknown, 모르는 값), `z` (high-impedance, 떠 있는 상태), `?` (와일드카드)

---

## 4. 주요 구문

### always 블록
하드웨어의 동작(변화)을 기술하는 구문이다.

형식:  
`always @(트리거 조건)`  
`begin` … 동작 내용 … `end`

트리거 조건에는 다음과 같은 형태가 있다.  
- `posedge clk` : 클럭이 0 → 1로 상승하는 순간  
- `negedge rst` : 리셋이 1 → 0으로 하강하는 순간  
- `(*)` : 블록 안의 신호가 바뀔 때마다 자동 실행 (조합 논리용)

예:  
`always @(posedge clk or negedge rst)`  
`if (!rst) count <= 0; else count <= count + 1;`

→ 리셋이 걸리면 즉시 초기화, 그렇지 않으면 클럭마다 카운트 증가.

---

### initial 블록
시뮬레이션 시작 시 **딱 한 번만 실행**되는 블록.  
보통 테스트벤치에서 초기값 설정이나 클럭 생성에 사용된다.

예:  
`initial begin clk = 0; forever #5 clk = ~clk; end`

---

### assign
조합 논리(즉시 계산되는 연결)를 표현한다.  
`assign y = a & b;` → 항상 a와 b의 AND 결과를 y에 연결.

---

### if / else
조건 분기 구문. 한 줄일 경우 `begin` / `end` 생략 가능.

예:  
`if (enable) q <= d; else q <= 0;`

---

### case
다중 분기 구문.  
`case (opcode) 4'b0000: out = A + B; 4'b0001: out = A - B; default: out = 0; endcase`

`casez` 또는 `casex`를 사용하면 `x`나 `z`를 무시하는 “don't care” 비교가 가능하다.

---

### for / while
시뮬레이션이나 반복적인 하드웨어 생성에 사용된다.

예:  
`for (i = 0; i < 8; i = i + 1) sum = sum + data[i];`

주의: 실제 회로 합성 시 반복문은 **동시에 펼쳐진 병렬 구조로 변환**된다.

---

## 5. 논리 연산자와 비교 연산자

- `& | ^ ~` : AND, OR, XOR, NOT  
- `== !=` : 비교  
- `&& ||` : 논리 AND / OR  
- `< <= > >=` : 크기 비교  

---

## 6. 비동기 / 동기 구조

- `always @(posedge clk)` : 클럭 엣지에 동기화된 회로 (레지스터 동작)  
- `always @(*)` : 조합 논리 회로  

리셋 처리:  
`always @(posedge clk or negedge rst)`  
`if (!rst) q <= 0; else q <= d;`

---

## 7. 블로킹 / 논블로킹 할당

Verilog는 두 종류의 대입을 지원한다.

- `=` (blocking): 즉시 실행, 순서대로 진행됨  
- `<=` (nonblocking): 클럭 엣지 이후 동시에 갱신됨  

**규칙:**  
조합 논리(`always @(*)`)에서는 `=` 사용,  
동기 회로(`always @(posedge clk)`)에서는 `<=` 사용.

---

## 8. 클럭과 시간 지연

시뮬레이션에서 시간 단위는 `#`으로 표현된다.  
예: `#10` → 10ns 기다림  

`always begin clk = 0; #5 clk = 1; #5; end`  
→ 10ns 주기의 클럭 파형 생성.

---

## 9. 모듈 인스턴스화

모듈을 다른 모듈 안에서 사용할 수 있다.  
`모듈이름 인스턴스명(.포트명(연결신호), ...);`

예:  
`counter my_counter(.clk(clk), .rst(rst), .count(count));`

---

## 10. 시뮬레이션 용어 요약

- `initial` : 시뮬레이션 시작 시 1회 실행  
- `always` : 시뮬레이션 종료까지 반복  
- `posedge` / `negedge` : 엣지 트리거  
- `#delay` : 시간 지연  
- `$display`, `$monitor` : 콘솔 출력  

예시:  
`$display("count=%d", count);`

---

## 11. 주석

한 줄 주석: `//`  
여러 줄 주석: `/* ... */`

---

## 12. 기본 규칙 정리

- `begin` / `end`는 여러 문장을 묶을 때 필수  
- 모든 하드웨어 동작은 동시에 일어난다 (병렬)  
- 시뮬레이션에서는 `#delay`로 시간 흐름 제어  
- 실제 합성 대상 코드는 `#delay`나 `$display`를 포함하면 안 됨  
- 변수는 반드시 초기화되거나 리셋되어야 한다  

---

## 13. 읽는 요령

Verilog 코드는 순서가 아니라 **타이밍과 조건**으로 이해해야 한다.  
`always @(posedge clk)` → 시계의 틱  
`if (!rst)` → 리셋 순간  
`assign` → 즉시 반응하는 전선  
`reg` → 값을 저장하는 플립플롭  

---

## 14. 더 배우고 싶다면

- 회로 합성(시뮬레이션과 다른 실제 하드웨어 변환 과정)  
- testbench 작성과 waveform 분석 (`gtkwave`)  
- SystemVerilog 확장 문법 (더 안전하고 현대적)

---

이 요약은 Verilog의 실제 동작과 구조를 직관적으로 이해하는 데 목적이 있다.  
하드웨어를 코드로 표현하는 언어이기 때문에, 항상 “이게 전기적으로 어떻게 연결되는가?”를 상상하면서 읽는 게 핵심이다.
